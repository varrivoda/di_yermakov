Алекесандр Ермаков
DI контейнеры

что такое инверсия зависимостей?
малые


SOLID
-некое описание,как _теоретически_ должно однозначно выглядеть О-О Приложение 
...для того, чтобы считать его О-О.

IoC это один из принципов

Что же мы инвертируем?
"Не детали контроллируют абстракцию, а абстракция контроллирует детали"

В классическом императивном программировании мы пишем программу, состоящую из деталей,
вызываемых в опр последовательности

Когда же мы пишем О-О программу, мыберем некую абстракцию, 
а потом в эту абстракуцию вставляем детали

В результате чего замена деталей приводит к тому, что слегка меняется поведение,
 но при этом не требуется менять абстракцию
 
IoC существует в двух ипостясях:
есть Dependency Injection и Dependency Pull

...
..

более правильно сделать,чтобы была интерфейсная ссылка,
в которую мы _подкладываем_ какие-то реалищации

|	class A{
|		Bable b;
|		...
|	}
|	
|	interface Bable{}
|	
|	class B implements Bable{
|	}

DI предполагает,что мы каким-то внешним способом вкласс A подложим класс B.
DPull говорит о том, что класс A сам знает, откуда ему надо подтащить B.

#Цель занятия:
Сегодня мы напишеи свой IoC контейнер
Будем писать приложение, которое умеет подобрать классу A нужный ему объект,
вставить в класс А и таким образом подготовить его к использоватию.
[15:44]

#Задача
Сделать Солнечную систему

С.С состоит из:
центральной Звезды
н-ного кол-ва планет

заведём классы Sun и Planet: 

|	class Sun{
|		....		
|	}
|
|	class Planet{
|		String planet;
|
|		public Planet(String planet){
|			this.planet = planet;
|		}
|	}
|
|	class SolarSystem{
|		Sun sun;
|		List<Planet> planet = new ArrayList<>();
|	}


<- мы тут

теперьам нужно создаиь объект это сол системы,
и нам хочется, чтобы солн система создавалась какбы сама собой
т.е. чтобы мы не создавали Солнце,планеты..
т.е.лично мы отвеаем только за создание сол системы,
 а за создание С и П отвечают другие люди, например коллеги.
 т.е.мыхотим сделать разделение ответственности.
 
 когда я сказал,что у нас есть С и П-ты, мы сделали некую абстракцию,
 от которой теперь будут отталкиваться коллеги.
 Они будутотвечать за созддание планет и С,
 а мы хотим просто изимеющегося списка создать новую С.С.
 
 Как мы можем это сделать?
 (учитывая,что у нас нет никокого Спринга или механизма внедрения зависимостей,
 а есть только камни с палками)
 
Зададим вопрос по другому:
 откуда мы будем брать планеты?
 ...
 сеттер, конструктор - сомнительно: 

?	public static void main(String[] args){
?		Sun sun = new Sun(5);
?		Planet planet1 = new Planet("Earth");
?	}
всё равно это делаем Мы, своими руками. 

А нам нужно, чтобы это делал кто-то другой.
И аже более того- чтобы другие сделали целый набор звёзд и планет,
а мы могли бы отфильтровать и выбрать лишь часть для своей С.С.
например,выюбрать самое яркоое извсех Солнц,которые насоздавали коллеги,
или планеты......
 ...
 ..
 .
(вспомним,что такое Bean? это некий объект,но откуда он берется?
какпланеты берутся из газовых облаков, так и бин попробуем создать из наших мозгов %-)

Первые попытки решить эту задачу представляли собой конфигурационный файл
где наши коллеги прописывали способ создания объектов
Есть только одна проблема:
мы не будем парсить xml! это  дичь. 

поэтому мы поставим аннотации, и будем ее рефлексивно просматривать
2 вопроса:
	куда мы поставим аннотации?
	и что мы будем  рефлексивно просматривать?
	
..
надо чтобы каждый коллега в своем файле нагененировал свооих планет,
а мы просмотрели и выбрали
..

каждый коллега сделает класс Config.java

	public class Config{
		public static Planet getPlanet(){
			return new Planet("Earth");
			// do something...
		}
		
		public static Planet getPlanet2(){
			// do something...
			return new Planet("Earth");
		}
		
		public static Planet getSun(){
			// do something...
			return new Sun(7);
		}
	}

каждый из коллег заливает эти файлы на гитхаб,
 и теперь наша задача - пройти по ним,
 и получить все методы, возвращающие то, что нам нужно

?как будем проходить?
будем использовать рефлексию и аннотации

создадим новую аннотацию - @interface Bean
и каждый метод, создающий бин, помечаем аннотацией @Bean

и затем рефлексивно обходим все методы, помееннные @Bean
 чтобы их куда-то положить....куда?
 напишем особый класс - Container
 
 который содержит все объекты, которые соберём из конфига/
 т.е. создадим в нём List<Object> 
	(сделаем его приватным, чтобы нельзя было добавить вручную,
	значит нужен геттер - listObjects, возвращающий new ArrayList c нашими objects - почему?)
 
 а также публичный метод load(), который подгружает Config.
 Он ничего не возвращает, но зато принимает (Class class)
 
 как будем подгружать?
сначала подумаем, как будем работать с конфигом... 
Идём в main()
	создаем new Container();
	container.load(Config.class);
			(а лучше - из пакета)
	берём оттуда listObjects();
		...(уже сейчас, с точки зрения абстракции, всё работает
		...правда,возвращает пустой лист :)
		
	можно вытащить типы классов с помощью instanceOf()
	- для этогопотребуется конструкция из for и if'ов....
		
		for (i=0; i<listObjects.size; i++){
			if(listObjects.get(i) instanceof Sun){ 
				sSystem.sun = (Sun)listObjects.get(i);
			}else{
				sSystem.planets.add((Planet)listObjects.get(i));
			}
		}
	...
	всё должно работать.
	
осталось только определиться, как будем подгружать из конфига?	
	(в конфиге методы статические,зачит получать экземпляр класса не нужно)

Идём в метод load() класса Config.java
берем у класса методы (возвр-ся как массив):
	Method[] methods = class.getDeclaredMethods()
		(далее можно былобы в цикле пройти все элементымассива,
		и получить лист объектов,которые они вовращают....
		но! зачем тогда мы делали аннотации?)
	лучше так:
	for(Method m:methods){
		if(m.isAnnotationPresent(Bean.class)) 
			objects.add(m.invoke(null));
	}
	ну и конечно пометим метод load() аннотацией @SneakyThrows 
		(? что это???? lombok.SneakyThrows)
	
***
В этом коде есть ряд допущений, при которых он будет работать:
	1) что методы гарантированно статические, объект не нужен
	2) методы публичные
	3) методы созданы непосредственно  внутри [Main.java? неразборчиво]
		, а не где-н в классах наследниках. С этим мы не  будем бороться.
	
**
проверили - не работает.
почему?
смотрим на аннотацию - "в рантайме не работает". 
"Самая частая причина при обработке аннотаций - забывать поставить Рантайм". 
Это значит, что нужно добавить аннотацию @Retention(RetencionPolicy.RUNTIME) 
	перед объявлением интерфейса @Bean
**
опять не работает.
??
возвращается к перечнюметодов (в теле load() печатаем список методов Arrays.asList(m....))
	 - все возвращает
заходим внутрь цикла - есть
внутрь if - нет. AnnotationPresent не сработало. Почему?
	возвр в for и печяатаем m.getDeclaredAnnotations()
в чем дело?
	аннотация Bean есть (IDE видит)
	RetentionPolicy прописан
	
	...
	после переименования интерфейса-аннотации Bean 
		и везде в коде 
		и названия файла - всё заработало!
	скорее всего не перекомпилировался файл
[54:00]	
***
теперь наши зависомости помечены Bean'ами,
внутри контейнера мы проходимся по всем методам класса Config
и добавляем все, имеющие аннотациюй Bean
замечательно.

примерно этим и должен заиматься контейнер зависимостей
В нашем примере мы храним только строго объекты,и больше ничего

не занимаемся их обработкой
не удобно предоставляем им доступ
а самое главное - чтобы получить конкретную реализацию зависимости,
мы по сути выполняем Dependency pull
т е нам приходится явно вытягивать из контейнера зависимости,
чтобывоткнуть их в Main

пока еще мы занимаемся не ввнедрением З, а подтягиваем зависимости
мы получили ссылку на конейнер, и можем вручную тягать из него наши объекты

Ктому же, это делать нам не особо удобно, потому что...
должны получать полный список, апотом ходить по этому списку
а если в списке будет 2000 планет? и одно Солнце...

как мы можем сделать поудобннее?

// вопрос из зала, в чем разницп междду DI контейнером и контекстом приложения?
// ответ: а мы сейчас как раз и пищшем appluication context

иитак, как мы можем сделать поудобнее?

во-первых, чтолбы было проще вытаскивать, 
можно добавлять не в Лист,а в Мапу

что сделаем ключом?
ключом могло бы быть некое название,например имя планеты
оно не у всех объектов может быть имя (например,у Солнца)
хеш-код тожене подходит (из-за неудобства)

что в наших объектах уникальное?
вариант 1 - название метода
вариант 2 - может присвоить имя аннотации? а также дефолтное значение ""

public @interface Bean{
	String name() default "";
 }

тогда сможем поставить на Солнце имя "sun", а все планеты будут "",
и мы сможем отличить их в контейнере
[1:06:20]

как переписываем?

в переборе методов вытащим имя аннотации
	...
	String txt = m.getAnnotation(Bean.class).name();
проверяем значение на  пустоту,тк в бинедефолтное значение пустое,
если же
	txt = txt.isEmpty?m.getName():txt;

***
IDE ругается
надо переименовать в Бине переменную name в value,
"потому что мыходим одноэлементную аннотацию, => имя должно быть value"
если бы там оставался name, пришлось бы писать @Bean(name="sun") вместо @Bean("Sun")
также переделаем в контейнере
***

итак
String txt берем в аннотации.value,
если пусто, берем имя метода, если не пусто, оставляем txt
put в мапу (txt, m.invoke(null))

теперь наконец-то в методе gertBean(name) 
можем ретурн по ключу listObjects.get(name)

==
а как нам быть, чтобы тип возвращаемого объекта был не Object, а Планета?
перепишем метод getBean:
тип значения делаем дженериком 
	public <T> T getBean(String name){
		return (T) listObject(name);
	}

однако чтобы нормально раотало, нужно передать еще и класс <T>-шки
	....		getBean(String name, Class<T> cl) 
при этом переменнную cl можно игнорировать, т к оно нужно только для корректной работы return (T) ...

Всё! теперь вместо перебора for-ом можем сделать просто:
sSystem.sun= container.getBean("sun", Sun.class)
должно работать! [1:13:30]

	(правда куча Варнингов и Ноутес возникает)
		warning: Implicitly compiled files were not subject to annotation processing.
	Use -proc:none to disable annotation processing or -implicit to specify a policy for implicit compilation.
		Note: .\example\Container.java uses unchecked or unsafe operations.
		Note: Recompile with -Xlint:unchecked for details.

если класс неприводимый (например всписок планет добавляемСолнце),
 мы получим КлассКастЭксепшн при чем в рантайме
 
 ...
 итак,как повысить удобство? 
 
 во0первых у нас сплошной dependency pull,
 а надо dependency injection
 мы сами собираем объекты по списку,  и далее получаем кним доступ
 хорошо,объектыесть - ну и что?
 
	(кстати вопрос: если бы мы оставили объектыхраниться в списках,
	а не поменяли на мапу - что было бы, если мы продублировали вызов container.load() ?
 
 
 а еще? что будет если по одному ключу разные люди добавят планеты с разными параметрами?
 в этом случае в мапу добавится вторая планета, а первая пропадет. напишем исключение 
	if(mapObjects.containsKey(txt)) throw new IllegalArgumentException("Duplicate bean!"+txt);
	mapObjects.put(....
///на двнном этапе не можемпроверить,
/// т к не можем объявлить 2 одинаковых метода в одном коонфиг классе 
	
но если честно, надо разделить процесс установки 
- где находится конфиг, и 
- процесс обновления-рефреш

по-хорошему в Контейнере должен храниться класс или массив (задаем в конструкторе)
а метод load() это на самом деле refresh(), 
и мы вызываем его вконструктооре
перед рефрешем очищаем мапу mapObjects.clear()


и если нужно,потом мы подгружаем, 
при чем теор может подгружать множестволлюдей,тогда мы будем принимать в конструкторе варарг
есть многоспособов

и вообще всем этим есть смысл заниматьс,если многолюдейработают и взиамодействуют
многофайлов каонфигураций(сейчаасне будем)

	сложный вопрос:
	ейчасgetSun возвращается с 7-кой
	ачто делать,естли возращается рандомное значение?
	
	getSun(){
		java.util.Random r= new Randomn();
		retirn r.nextInt(10);
	{

	(	кстаии, этот примерхорошо показывает, чем методы, возвр объекты, 
		лучше простыхполей, дата обжектов и т.д		)
		
и мы хотим,чтобы этот код работал не один раз, когдамы первый раз создаем мапу
а чтобы он работал каждый раз, когда мы получаем доступ к бину

т.е в нашем случае с рандомом каждый раз ддолжно быть разное солнце.
и при двойном вызове тоже

(паттерн неочень подходит)

нам нужно понять, чем наш Sun принципиально отличается от других объектов

вариантов два:
вообще не хранить объекты, а хранить только методы 
	Map(String, Method)
тогда делая getBean будем просто возвращать
проходиться по всем методам,выбирать метод с нужным назхваниекм,и выбиратиь его

проблема толко в произволительности
каждый рах вызывать  методы,кторые не нужный

вариант 2й - хранить 2 вида объектов, простые объекты и методы
надо разделить бины

чтобы пометить те бины,которые нужновызывать заново,
напишем новую аннота2цию - @Prototype

в рефреше: 
если присутстввует аннотация Прототайп
	mapObjects.put(key, null)
else
	...put(key, m.invoke(null))
	
в getBean()
если значение пустое, 
	нужно вызвать какой-то метод

какой?
заведем вторую мапу, в которую сложим методы
mapMethods(String,Methods);

вернемся в рефреш, после put в Обжектс null
mapMethods.put(key, m) 
(не инвок)

вернемся в гетБин
возвразщаем Инвок,если обжектс пустой
return methods(name).invoke(null);

метод <T> T гетБин перегрузим
return (T) getBean(name);

должно работать!
[1:36:00]

когда мы помечаем бин, то храним объект
когда ставим прототип, то храним только способ создания

с т.з. контейнера, бин это объект, жиз циклом которогоупр непосред контейнер
онсамговорит,когдаи как его создать ит.д. (сейчас не заостряемся)

[1:38:00]

что еще?

//
// ЭТО ВИРТУАЛЬНОЕ ИЗМЕНЕИЕ ДЛЯ ПРОВЕРКИ АВТОПУШИНГА
//
