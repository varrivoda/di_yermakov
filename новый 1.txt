Алекесандр Ермаков
DI контейнеры

что такое инверсия зависимостей?
малые


SOLID
-некое описание,как _теоретически_ должно однозначно выглядеть О-О Приложение 
...для того, чтобы считать его О-О.

IoC это один из принципов

Что же мы инвертируем?
"Не детали контроллируют абстракцию, а абстракция контроллирует детали"

В классическом императивном программировании мы пишем программу, состоящую из деталей,
вызываемых в опр последовательности

Когда же мы пишем О-О программу, мыберем некую абстракцию, 
а потом в эту абстракуцию вставляем детали

В результате чего замена деталей приводит к тому, что слегка меняется поведение,
 но при этом не требуется менять абстракцию
 
#IoC существуетв друх ипостясях:
есть Dependency Injection и Dependency Pull

...
..

более правильно сделать,чтобы была интерфейсная ссылка,
в которую мы _подкладываем_ какие-то реалищации

|	class A{
|		Bable b;
|		...
|	}
|	
|	interface Bable{}
|	
|	class B implements Bable{
|	}

DI предполагает,что мы каким-то внешним способом вкласс A подложим класс B.
DPool говорит о том, что класс A сам знает, откуда ему надо подтащить B.

#Цель занятия:
Сегодня мы напишеи свой IoC контейнер
Будем писать приложение, которое умеет подобрать классу A нужный ему объект,
вставить в класс А и таким образом подготовить его к использоватию.
[15:44]

#Задача
Сделать Солнечную систему

С.С состоит из:
центральной Звезды
н-ного кол-ва планет

заведём классы Sun и Planet: 

|	class Sun{
|		....		
|	}
|
|	class Planet{
|		String planet;
|
|		public Planet(String planet){
|			this.planet = planet;
|		}
|	}
|
|	class SolarSystem{
|		Sun sun;
|		List<Planet> planet = new ArrayList<>();
|	}


<- мы тут

теперьам нужно создаиь объект это сол системы,
и нам хочется, чтобы солн система создавалась какбы сама собой
т.е. чтобы мы не создавали Солнце,планеты..
т.е.лично мы отвеаем только за создание сол системы,
 а за создание С и П отвечают другие люди, например коллеги.
 т.е.мыхотим сделать разделение ответственности.
 
 когда я сказал,что у нас есть С и П-ты, мы сделали некую абстракцию,
 от которой теперь будут отталкиваться коллеги.
 Они будутотвечать за созддание планет и С,
 а мы хотим просто изимеющегося списка создать новую С.С.
 
 Как мы можем это сделать?
 (учитывая,что у нас нет никокого Спринга или механизма внедрения зависимостей,
 а есть только камни с палками)
 
Зададим вопрос по другому:
 откуда мы будем брать планеты?
 ...
 сеттер, конструктор - сомнительно: 

?	public static void main(String[] args){
?		Sun sun = new Sun(5);
?		Planet planet1 = new Planet("Earth");
?	}
всё равно это делаем Мы, своими руками. 

А нам нужно, чтобы это делал кто-то другой.
И аже более того- чтобы другие сделали целый набор звёзд и планет,
а мы могли бы отфильтровать и выбрать лишь часть для своей С.С.
например,выюбрать самое яркоое извсех Солнц,которые насоздавали коллеги,
или планеты......
 ...
 ..
 .
(вспомним,что такое Bean? это некий объект,но откуда он берется?
какпланеты берутся из газовых облаков, так и бин попробуем создать из наших мозгов %-)

Первые попытки решить эту задачу представляли собой конфигурационный файл
где наши коллеги прописывали способ создания объектов
Есть только одна проблема:
мы не будем парсить xml! это  дичь. 

поэтому мы поставим аннотации, и будем ее рефлексивно просматривать
2 вопроса:
	куда мы поставим аннотации?
	и что мы будем  рефлексивно просматривать?
	
..
надо чтобы каждый коллега в своем файле нагененировал свооих планет,
а мы просмотрели и выбрали
..

каждый коллега сделает класс Config.java

	public class Config{
		public static Planet getPlanet(){
			return new Planet("Earth");
			// do something...
		}
		
		public static Planet getPlanet2(){
			// do something...
			return new Planet("Earth");
		}
		
		public static Planet getSun(){
			// do something...
			return new Sun(7);
		}
	}

каждый из коллег заливает эти файлы на гитхаб,
 и теперь наша задача - пройти по ним,
 и получить все методы, возвращающие то, что нам нужно

?как будем проходить?
будем использовать рефлексию и аннотации

создадим новую аннотацию - @interface Bean
и каждый метод, создающий бин, помечаем аннотацией @Bean

и затем рефлексивно обходим все методы, помееннные @Bean
 чтобы их куда-то положить....куда?
 напишем особый класс - Container
 
 который содержит все объекты, которые соберём из конфига/
 т.е. создадим в нём List<Object> 
	(сделаем его приватным, чтобы нельзя было добавить вручную,
	значит нужен геттер - listObjects, возвращающий new ArrayList c нашими objects - почему?)
 
 а также публичный метод load(), который подгружает Config.
 Он ничего не возвращает, но зато принимает (Class class)
 
 как будем подгружать?
сначала подумаем, как будем работать с конфигом... 
Идём в main()
	создаем new Container();
	container.load(Config.class);
			(а лучше - из пакета)
	берём оттуда listObjects();
		...(уже сейчас, с точки зрения абстракции, всё работает
		...правда,возвращает пустой лист :)
		
	можно вытащить типы классов с помощью instanceOf()
	- для этогопотребуется конструкция из for и if'ов....
		
		for (i=0; i<listObjects.size; i++){
			if(listObjects.get(i) instanceof Sun){ 
				sSystem.sun = (Sun)listObjects.get(i);
			}else{
				sSystem.planets.add((Planet)listObjects.get(i));
			}
		}
	...
	всё должно работать.
	
осталось только определиться, как будем подгружать из конфига?	
	(в конфиге методы статические,зачит получать экземпляр класса не нужно)

Идём в метод load() класса Config.java
берем у класса методы (возвр-ся как массив):
	Method[] methods = class.getDeclaredMethods()
		(далее можно былобы в цикле пройти все элементымассива,
		и получить лист объектов,которые они вовращают....
		но! зачем тогда мы делали аннотации?)
	лучше так:
	for(Method m:methods){
		if(m.isAnnotationPresent(Bean.class)) 
			objects.add(m.invoke(null));
	}
	ну и конечно пометим метод load() аннотацией @SneakyThrows 
		(? что это???? lombok.SneakyThrows)
	
***
В этом коде есть ряд допущений, при которых он будет работать:
	1) что методы гарантированно статические, объект не нужен
	2) методы публичные
	3) методы созданы непосредственно  внутри [Main.java? неразборчиво]
		, а не где-н в классах наследниках. С этим мы не  будем бороться.
	
**
проверили - не работает.
почему?
смотрим на аннотацию - "в рантайме не работает". 
"Самая частая причина при обработке аннотаций - забывать поставить Рантайм". 
Это значит, что нужно добавить аннотацию @Retention(RetencionPolicy.RUNTIME) 
	перед объявлением интерфейса @Bean
**
опять не работает.
??
возвращается к перечнюметодов (в теле load() печатаем список методов Arrays.asList(m....))
	 - все возвращает
заходим внутрь цикла - есть
внутрь if - нет. AnnotationPresent не сработало. Почему?
	возвр в for и печяатаем m.getDeclaredAnnotations()
в чем дело?
	аннотация Bean есть (IDE видит)
	RetentionPolicy прописан
	
	...
	после переименования интерфейса-аннотации Bean 
		и везде в коде 
		и названия файла - всё заработало!
	скорее всего не перекомпилировался файл
[54:00]	

	


